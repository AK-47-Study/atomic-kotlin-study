
**16 객체는 모든 곳에 존재한다**
- 클래스(class)
	- 사용자 정의 타입이라고 함
	- 새로운 데이터 타입의 기초가 될 프로퍼티와 함수를 정의
	- 상태와 행동을 정의
- 멤버(member)
	- 클래스에 속한 프로퍼티나 함수
- 멤버 함수(member function)
	- 특정 클래스에 속한 객체가 있어야만 사용될 수 있는 함수(함수 안에 정의됨)
	- 자바 등에서는 메서드(method)라고 부름
		- method는 초기 객체 지향 언어인 스몰토크 등에서 비롯된 용어
- 객체 생성
	- 클래스에 해당하는 val, var 값을 만드는 과정
	- '인스턴스 생성'이라고도 함 -> 자신만의 저장 공간을 가짐
	- 객체에 대해서는 여러 가지 연산을 수행 가능 -> 멤버 함수 호출
		- 멤버함 수 호출 방법: 식별자 지정 + .(점) + 연산

**17 클래스 만들기**
- 직접 원하는 객체의 타입을 정의 가능 -> 객체 지향 프로그래밍 활동의 상당 부분을 차지
- 문제 해결에 필요한 개념을 표현하는 객체를 생각하는 습관
- **class** 키워드를 사용하여 새로운 유형의 객체를 생성
	- class 키워드 + 식별자(클래스 이름, 반드시 글자로 시작, 관례적으로 대문자 시작)
- 클래스 본문(class body)
	- 클래스의 특성, 행동 양식을 포함
- this: 멤버 함수 안에서 객체를 가리키는 참조에 접근할 때 사용
	- 불필요한 this는 사용하지 않는 것이 좋음
	- this를 반드시 적어야 하거나, 적는 스타일을 권장하는 언어가 아니라면 사용 X


**18 프로퍼티**
- 프로퍼티는 클래스에 속한 var/val
- 프로퍼티를 정의함으로써 클래스 안에서 상태를 유지 -> 함수 대신 클래스를 작성하는 주된 이유
- var 프로퍼티는 재대입 가능
- val 프로퍼티는 재대입 불가능
- 각 객체는 프로퍼티를 저장할 공간을 따로 할당 받음
- 클래스 내부의 프로퍼티는 클래스의 일부분 -> 점 표기법으로 접근 가능

- 멤버 함수는 점 표기법 없이 자신이 속한 객체의 프로퍼티에 접근 가능
	- 클래스 밖에서는 멤버 함수, 프로퍼티 모두 한정시켜야 함(점 표기법 사용)

- val은 불변이므로 최상위 수준 정의해도 안전
- var은 가변이므로 최상위 수준 정의 시 안티패턴으로 간주
	- 프로그램이 복잡해지면 공유된 가변 상태는 추론이 어려우므로
	- 마치 setter를 사용하는 느낌
	- 가변 상태는 클래스 안에 가두는 것이 가장 좋음

- var sofa = Sofa()에서 sofa는 객체를 가리키는 **참조**
- var와 val은 객체가 아니라 참조를 제한하는 것임
	- var은 참조가 가리키는 대상을 다른 대상으로 다시 엮을 수 있으나, val은 불가능
- 즉, **객체의 가변성**은 내부 상태를 바꿀 수 있다는 뜻


**19 생성자**

- 생성자에 정보를 전달해 새 객채를 초기화
- 생성자는 새 객체를 초기화하는 특별한 멤버 함수 개념
	- 한 줄짜리 클래스 정의: 가장 간단한 형태의 생성자
	- 생성자 파라미터를 var, val로 정의하면 식별자가 프로퍼티로 바뀜 -> 밖에서도 접근 가능
- println()은 객체를 전달받을 경우 객체의 toString()을 호출한 결과를 출력
	- 직접 toString()을 정의하지 않으면 디폴트 toString()
	- 디폴트 toString()은 유용하지 않음(클래스 이름 + 객체의 물리적 주소를 출력)

- override 키워드: 이미 정의된 메서드의 정의를 재정의할 때 사용
	- 명시함으로써 코드 의도 명확 + 실수 줄임



**20 가기성 제한하기**

- 리팩터링을 하는 주된 이유
	- 코드를 다시 보면 더 좋은 방법이 보일 때가 많음
	- 더 읽기 좋고 이해하기 쉽게 그래서 유지보수가 쉽게 만들기 위함
	- 하지만 클라이언트는 코드가 안정적이길 원함 = 코드가 유지되길 원함
	- 변경 내용이 클라이언트 코드에 영향을 끼치지 않는다는 확신으로 수정, 개선이 가능해야 함

  

- 소프트웨어 설계 고려 사항
	- 변화해야 하는 요소와 동일하게 유지되어야 하는 요소를 분리하라.

- 접근 변경자(access modifier)
	- 가시성을 제어하기 위한 방법
	- public, private, protected, internal 등
	- 클라이언트가 접근할 수 있는 범위를 결정
	- 변경자는 클래스, 함수, 프로퍼티 정의 앞에 위치
	- 변경자가 붙어 있는 그 정의의 가시성만 제한 가능
	- 클라이언트는 public 정의에 접근 가능
		- public으로 선언된 정의 변경 시 클라이언트에 직접적으로 영향
		- 변경자 미 지정 시 자동으로 public -> 기술적으로 불필요한 중복(명확한 의도 전달을 위해 사용하는 경우 제외)
	- private 정의는 숨겨져 있음
		- 같은 클래스에 속한 다른 멤버들만 접근 가능
		- 정의 변경, 삭제하더라도 클라이언트에 직접적인 영향 없음
		- private가 붙은 클래스, 최상위 함수, 취상위 프로퍼티는 그 정의가 있는 파일 내부에서만 접근 가능
		- 주로 클래스 멤버에 사용됨
	- 클라이언트에 필요한 함수와 클래스만 외부에 노출 + 가능한 한 많은 요소를 private로 선언
	- 클래스 내 프로퍼티는 내부 구현을 노출시켜야 하는 경우 제외하고 private로 만들기
		- 클래스 내부에 있는 참조를 private로 정의해도 그 참조가 가리키는 객체에 대한 public 참조가 없다는 사실을 보장하지는 않음
		- 에일리어싱(aliasing): 한 객체에 대해 참조를 여러 개 유지하는 경우
	- internal
		- 그 정의가 포함된 모듈 내부에서만 접근 가능
		- public과 private의 중간 성격
		- 라이브러리 내부에서 사용 가능, 라이브러리 소비자는 접근 불가


**21 패키지**
- Don't Repeat Yourself: DRY - 프로그래밍의 근본적인 원칙
	- 코드에서 같은 내용 반복 시, 수정이나 개선할 때마다 더 많은 유지 보수가 필요 + 실수 가능성 커짐
	- import 키워드를 통해 다른 파일에 정의된 코드를 재사용 가능
		- 클래스, 함수, 프로퍼티 이름을 지정하여 사용
		- import packagename.ClassName
		- import packagename.functionName
		- import packagename.propertyName

- 패키지(package)
	- 연관있는 코드를 모아둔 것
	- as 키워드를 사용해 이름 변경 가능 - 라이브러리 이름을 잘못 선택했거나 이름이 길 때 유용
	- 코드 안에서 임포트한 이름의 패키지 경로를 전부 다 쓸 수도 있음
	- 패키지 내 모든 내용 임포트하려면 별표(\*) 사용
	- package 키워드는 파일에서 주석이 아닌 코드의 가장 앞부분에 위치해야 함
	- 패키지 이름에는 소문자만 사용(관례)
	- 자바는 파일 이름과 클래스 이름이 같아야 하지만 코틀린은 소스 코드 파일 이름으로 아무 이름이나 상관 없음
	- 패키지 이름도 아무 이름이나 선택 가능하지만 패키지 이름과 패키지 파일이 들어있는 디렉터리의 경로를 똑같이 하는 게 좋은 스타일


**22 테스트**
- 테스트는 매우 중요한 개발 습관 -> 테스트를 통해 문제를 즉시 발견 가능
- println()을 사용한 코드 검증은 부실한 접근 방법
- 테스트 시스템의 목표
	- 식의 예상 결괏값 보여주기
	- 프로그램이 실행되고 있음을 알 수 있는 출력 제공 + 모든 테스트 성공 시 출력 제공
	- 테스트의 개념 익히기
- 테스트 시스템 예시
	- JUnit: 자바의 테스트 프레임워크. 코틀린에서도 유용하게 쓰임
	- Kotest: 코틀린 전용으로 설계
	- Spek: 명세 테스트(specification test) 형태의 테스트 제공
- 중위 표기법(infix notation)
	- a.함수(b) -> a 함수 b
	- infix 키워드를 붙인 함수만 중위 표기법을 사용해 호출 가능

- AtomicTest
	- eq, neq:  식과 예상값을 비교
	- trace: 출력을 저장해서 나중에 사용할 수 있게 해줌. println()을 대치

- 테스트 주도 개발(Test Driven Development, TDD)
	- 코드 작성 전 테스트를 먼저 작성해 실패시킨 후,
	- 나중에 테스트를 통과하도록 코드를 작성
	- 함수를 만들 때, 테스트 외의 다른 이유가 없더라도 테스트를 위해 함수가 무언가를 반환하도록 함
	- 파라미터를 받아 결과값만 만들어내고 다른 일은 하지 않는 함수를 사용하면 설계가 더 나아짐


**23 예외**

- exception은 'I take exception to that'에 있는 것과 같은 뜻으로 쓰임
- 예외 상황은 현재 함수, 현재 영역의 진행을 막음
- 문제가 발생하면 해당 위치에서 무슨 일을 해야 할지 알 수 없어 현재 맥락에서 계속 처리 불가
	-> 문제 해결을 위한 충분한 정보가 없어 처리를 중단하고, 조치를 취할 수 있는 다른 맥락으로 문제를 넘겨야 함 -> 오류 보고 메커니즘 '예외'
- 중요한 것: 예외적인 상황과 일반적인 문제를 구분하는 것
	- 일반적인 문제: 문제 해결을 위한 충분한 정보가 현재 맥락에 존재하는 경우
	- 예외적인 상황: 처리 불가한 상황 -> 문제를 바깥쪽 맥락으로 내보내기

- 예외
	- 오류가 발생한 지점에서 '던져지는' 객체


**24 리스트**

- 리스트는 컨테이너(container), 즉 다른 객체를 담는 객체
- 컬렌션이라고도 하며, 표준 코틀린 패키지에 속해 있어 import 불필요
- 자기자신을 표시할 때 각괄호 사용
- List의 마지막 원소의 인덱스보다 큰 인덱스를 사용하면 ArrayIndexOutOfBoundException 던짐
- 타입 추론을 사용하는 것은 좋은 습관이나, 직접 타입을 명시해야 하는 경우도 있음
- 홑화살괄호(<>)는 타입 파라미터를 표시
	- 타입 파라미터: 컨테이너가 담을 객체의 타입에 대한 파라미터

- 가변 List
	- 필요하다고 명시적으로 표시해야만 얻을 수 있음
	- listOf()는 읽기 전용 리스트를 만듦
	- List를 점진적으로 만든다면 mutableListOf()를 사용 -> 변경할 수 있는 List
	- add(), addAll()을 사용해 원소 추가( '+='으로 대치 가능)
	- '+=' 연산자를 쓰면 불변 리스트가 마치 가변 리스트인 것처럼 보임
		- list가 var이므로 가능한 현상



**25 가변 인자 목록**

- vararg(variable argument list) 키워드는 길이가 변할 수 있는 인자 목록을 만듦
- 함수 정의에는 vargarg로 선언된 인자가 최대 하나만 있어야 함
- 어느 위치에 있는 파라미터든지 vararg로 선언 가능하지만 일반적으로 마지막 파라미터를 vararg로 선언
- 함수 본문에서는 파라미터 이름을 통해 vararg에 접근 가능하고 이때 파라미터는 Array 취급
	- Array와 List는 비슷해 보이지만 전혀 다르게 구현됨
	- List
		- 일반적인 라이브러리 클래스
		- 간단한 시퀀스가 필요할 때 사용
	- Array
		- 특별한 저수준 지원이 필요
		- 자바 같은 다른 언어와 호환되어야 한다는 요구사항에 의해 생김
		- 서드파티 API가 Array를 요구하거나 vararg를 다뤄야 하는 경우에만 사용
		- 항상 가변 객체
		- arrayOf()를 사용하여 Array를 만듦. 원시 타입의 Array를 전달할 때는 구체적인 타입 이름이 지정된 Array 생성 함수 사용
		- 인자 목록을 변환하고 싶다면 스프레드 연산자(\*) 사용
			- 스프레드 연산자는 vararg 파라미터를 다시 다른 vararg로 전달할 때 유용

- 명령줄 인자
	- 명령줄 인자를 받게 하려면 main() 함수에 미리 정해진 파라미터를 지정해야 함
	- 전통적으로 args로 짓고, 타입은 Array<\String>이어야 함



**26** 집합

- 각각의 값이 오직 하나만 존재할 수 있는 컬렉션
- List에서 중복을 제거하려면 Set으로 변환하거나 distinct()를 사용
- 가변 Set이 필요하면 mutableSetOf() 사용
- List와 마찬가지로 -=, += 사용 가능
- 


**27 맵**

- 키와 값(key & value)를 연결하고, 키가 주어지면 그 키와 연결된 값을 찾아줌
- 키와 값을 분리하려면 'to' 사용
- 일반 Map은 읽기 전용. MutableMap 따로 존재. 둘 모두 원소가 Map에 전달된 순서를 유지해줌
- key 관련 value 추가 및 변경: map[key] = value
- 키-값 쌍 명시적 추가: map += key to value
- + 연산은 기존 Map에 영향을 미치지 않음 -> 읽기 전용 Map에 원소를 '추가'하는 유일한 방법
- 주어진 키에 대한 원소가 없으면 null 반환
- null이 될 수 없는 결과를 원한다면 getValue() 사용 -> 없는 원소라면 'NoSuchElementException' 발생
- 일반적으로 getOrDefault()가 null 반환이나 예외를 던지는 함수보다 더 나은 대안
- 클래스 인스턴스를 Map의 값으로 저장 가능
- 간결하고 작은 DB와 비슷한 개념
- 키와 값을 연결시킨다는 의미에서 Associative Array(연관 배열)이라고 부르기도 함
- 


**28 프로퍼티 접근자**

- 프로퍼티 이름을 사용해 프로퍼티를 읽음
- 대입 연산자(=)을 사용해 가변 프로퍼티에 값을 대입
- 게터(getter)
	- 프로퍼티 값을 얻기 위해 사용하는 접근자
	- 프로퍼티 정의 바로 다음에 get()을 정의하면 게터를 정의할 수 있음
- 세터(setter)
	- 가변 프로퍼티를 갱신하기 위해 사용하는 접근자
	- 게터와 마찬가지 방법으로 정의
- 프로퍼티를 private로 정의하면 두 접근자 모두 private이 됨
- 각각에 서로 다른 접근 제어자를 사용 가능
- 일반적으로 프로퍼티는 값을 필드에 저장, 필드가 없는 프로퍼티도 정의 가능
- 코틀린 스타일 가이드는 계산 비용이 들지 않고 객체 상태가 비뀌지 않는 한 같은 결과를 내놓는 함수는 프로퍼티를 사용하는 편이 낫다고 안내함
- 프로퍼티 접근자는 프로퍼티에 대한 일종의 보호 수단을 제공


**29 2부 요약**
- package 키워드: 재사용이 가능한 라이브러리 컴포넌트를 원하는 만큼 묶을 수 있음
- trace(): println()을 효과적으로 대치하는 함수
- 코틀린은 '하이브리드 객체-함수형 언어': 객체 지향 + 함수형 프로그래밍 패러다임을 모두 지원
- 멤버 함수: 클래스 내부에 정의된 함수
- 프로퍼티: 객체 안의 var/val
- 클래스: 프로퍼티와 멤버 함수를 정의. 새로운 사용자 정의 데이터 타입을 정의하기 위한 프로그래밍 요소
	- 클래스에 속하는 val/var을 만드는 것 = 객체 생성 or 인스턴스 생성
	- class 키워드 + 클래스 이름 + 본문(선택. 프로퍼티 정의 + 함수 정의)
	- 