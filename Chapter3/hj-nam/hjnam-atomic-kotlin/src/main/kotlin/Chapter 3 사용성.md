
**30 확장 함수**

-  확장 함수(extension function)
	- 기존 클래스에 멤버 함수를 추가하는 것과 같은 효과
	- 수신 객체 타입(receiver type): 확장할 대상 타입
	- 정의 방법: 함수 이름 앞에 수신 객체 타입을 붙임
		- fun 수신_객체_타입.확장_함수_이름() { ... }
		- fun String.singleQuote() = "'$this'"
	- this 키워드를 사용해 멤버함수나 다른 확장에 접근 가능
	- 클래스 내부에서 this를 생략할 수 있듯이, 확장 함수 안에서도 this를 생략 가능
	- 확장 함수는 확장 대상 타입(수신 객체 타입)의 public 원소에만 접근 가능 ->  확장은 일반 함수가 할 수 있는 일만 처리 가능
	- 확장 함수 사용 이유 = this 사용함으로써 구문적 편의를 얻기 때문(systax sugar)


**31 이름 붙은 인자와 디폴트 인자**

- 함수를 호출하면서 인자의 이름을 지정 가능
- 이름 붙은 인자 사용 -> 코드 가독성 
	- ex) fun color(red: Int, green: Int, blue: Int) 
	- -> color( red = 76,  green = 89,  blue = 0)
	- 모든 인자에 이름을 붙이지 않아도 됨
	- 위치를 섞어도 되지만 대신 모두 이름을 붙여야 함
- 디폴트 인자: 파라미터의 디폴트 값을 함수 정의에서 지정하는 것
	- 값을 지정하지 않은 인자는 자동으로 디폴트 값으로 지정됨
	- 덧붙은 콤마: 마지막 파라미터 뒤에 추가로 붙인 콤마
		- fun color(red: Int = 0, green: Int = 0, blue: Int = 0 **,** )
		- 파라미터 값을 여러 줄에 걸쳐 쓰는 경우에 유용
		- 콤마를 추가하거나 빼지 않아도 새로운 아이템을 추가하거나 순서를 바꿀 수 있음
- 이름 붙은 인자와 디폴트 인자는 생성자에 써도 됨
- joinToString()
	- 디폴트 인자를 사용하는 표준 라이브러리 함수
	- 이터레이션 가능 객체(리스트, 집합 등)의 내용을 String으로 합쳐줌
	- 구분자, 접두사, 접미사 등을 지정 가능
- 객체 인스턴스를 디폴트 인자로 전달하는 경우
	- 호출할 때마다 같은 인스턴스가 반복해서 전달됨
- 디폴트 인자로 함수 호출이나 생성자 호출 등을 사용하는 경우
	- 함수를 호출할 때마다 새 인스턴스가 생기거나 디폴트 인자에서 호출하는 함수가 호출됨
- 인자 이름을 붙였을 때 가독성이 향상되는 경우에만 인자 이름을 지정
- trimMargin()
	- 소스 String의 각 줄 맨 앞에 있는 공백들 다음에 지정한 접두사 String까지를 잘라내서 문자열을 다음어줌
	- 여러 줄 문자열의 첫 번째 줄과 마지막 줄 중에 공백으로만 이루어진 줄을 제거


**32 오버로딩**

- 디폴트 인자를 지원하지 않는 언어에서 디폴트 인자를 흉내 내기 위해 오버로딩을 사용함
- 파라미터 목록이 여러 다른 함수에 같은 이름을 사용하는 것
	- 함수의 시그니처 = 함수 이름, 파라미터 목록, 반환 타입
	- 코틀린은 시그니처를 비교하여 함수를 구분
	- 따라서, 오버로딩할 때는 함수 파라미터 리스트를 서로 다르게 만들어야 함
	- 함수 반환 타입은 오버로딩 대상이 아님
	- 함수 시그니처는 함수를 둘러싸고 있는 클래스도 포함(확장 함수의 경우 수신 객체 타입)
	- 클래스 안에 확장 함수와 시그니처가 똑같은 멤버 함수가 들어 있으면 멤버 함수 우선이지만 확장 함수를 가지고 멤버 함수를 오버로딩 가능
- 함수 오버로딩과 디폴트 인자를 함께 사용하는 경우
	- 오버로딩한 함수를 호출 시 함수 시그니처와 함수 호출이 '가장 가깝게' 일치되는 함수 호출
- 오버로딩이 유용한 이유
	- '같은 주제를 다르게 변경한다'는 개념을 더 명확하게 표현 가능
	- 예시) fun add(i: Int, j: Int) = i + j , fun add(i: Double, j: Double) = i + j
	- 가치가 있는 단순성을 얻을 수 있음 -> 가독성



**33 when 식**

- 패턴에 따라 어떤 동작을 수행하는 코드를 작성할 때 유용
- if 식보다 when 식이 훨씬 좋음 -> when이 더 유연함
- when으로 시작
- when 뒤의 괄호에는 비교 대상 값 또는 임의의 식
	- 인자가 없을 경우, 각 매치의 Boolean 조건을 검사. 따라서 이때는 화살표 왼쪽에 항상 Boolean 타입의 식을 넣어야 함
- 그 뒤에는 값과 일치할 수 있는 여러 매치(match)가 있는 본문
	- 각 매치는 오른쪽 화살표(->)로 시작
	- 가장 먼저 일치하는 매치식에서 when 식이 끝남
- when 식을 문처럼 취급하는 경우에만 else 생략 가능
- 매치 내용에 콤마를 써서 여러 값을 나열 가능



**34 이넘**

- 이넘은 이름을 모아둔 것
- enum의 이름에 해당하는 문자열을 돌려주는 toString이 생성됨
- 이넘은 인스턴스 개수가 미리 정해져 있고, 클래스 본문 안에 이 모든 인스턴스가 나열되어 있는 특별한 종류의 클래스
	- 이 점을 제외하면 enum은 일반 클래스와 똑같이 동작
	- 즉, 멤버 함수나 멤버 프로퍼티를 이넘에 정의 가능
		- 마지막 이넘 값 다음에 세미콜론을 추가한 후 정의를 포함시키면 됨
- 이넘은 코드 가독성을 향상시키므로 항상 사용하는 것이 바람직
- 



**35 데이터 클래스**

- 데이터를 저장하는 게 주목적인 클래스
- data 키워드를 사용
	- 이 때 모든 생성자 파라미터를 var/val로 선언해야 함
- data 클래스에 의해 만들어진 문자열은 파라미터 이름과 객체에 담긴 데이터 내용이 표시됨
	- toString() 코드를 추가하지 않아도 보기 좋은 형식으로 표현해줌
	- equals()가 자동으로 생성되고 이는 생성자 파라미터에 열거된 모든 프로퍼티가 같은지 검사
	- copy()가 자동으로 생성되고 이는 현재 객체의 모든 데이터를 포함하는 새 객체를 생성
		- 변경하고 싶은 인자만 지정하여 수정 가능


**36 구조 분해 선언**

- 결과를 돌려줄 때 결과와 함께 결과에 대한 다른 정보를 추가로 돌려주고 싶다면 'Pair' 클래스 사용
- 구조 분해 선언을 사용해 여러 식별자를 동시에 선언하면서 초기화 가능
	- val (a, b, c) = 여러 값이 들어있는 값
	- 객체를 여러 컴포넌트로 분해해서 순서대로 대입해줌
	- 식별자 이름(등호 왼쪽)을 **괄호 안**에 넣어야 함
- 'Triple' 클래스는 정확히 세 가지 값을 묶음
- 더 많은 값을 저장하고 싶거나 Pair, Triple을 많이 사용한다면 상황에 맞는 특별한 클래스를 작성해야 함
- data 클래스는 자동으로 구조 분해 선언을 지원
	- data 클래스 생성자에 각 프로퍼티가 나열된 순서대로 값이 대입
- Pair, Triple은 프로퍼티 순서가 바뀌지 않아 구조 분해해도 안전
- Pair, Triple 등을 '쌍', '튜플(tuple)'이라고 함
- withIndex()는 표준 라이브러리가 List에 대해 제공하는 확장 함수
	- 컬렉션의 값을 IndexdValue라는 타입의 객체에 담아서 반환 + 객체를 구조 분해 가능
- 구조 분해 선언은 지역 var/val에만 적용 가능
- 클래스 프로퍼티를 정의할 때는 사용 불가
- 


**37 널이 될 수 있는 타입**

- null을 정상적인 값과 같은 방식으로 다루면 치명적인 실패가 발생(ex. NullPointerException)
	- 해법1. null을 허용하지 않는 대신 특별한 '값 없음'을 표시할 표지를 도입
- 코틀린은 모든 타입이 널이 될 수 없는 타입(non-nullable)
- null 결과를 내놓을 수 있다면, 타입 이름 뒤에 물음표(?)를 붙여 null이 될 수 있음을 표시
- ?가 있는 타입과 없는 타입은 서로 다른 타입
- 자바에서는 거의 대부분의 값이 null이 될 수 있음
	- 함수 호출이 언제든 NPE로 끝날 가능성 존재
	- null 검사 코드 작성 또는 null 가능성 차단 코드에 의존해야 함
- 코틀린에서는 null이 될 수 있는 타입을 단순히 역참조 불가
	- 역참조: 멤버 프로퍼티나 멤버 함수에 접근하는 것
	- null이 될 수 있는 타입을 역참조하려면 '명시적으로 참조가 null인지 검사'해야 함
- 새 클래스를 정의할 때마다 코틀린은 자동으로 널이 될 수 있/없는 타입을 추가함
- 



**38 안전한 호출과 엘비스 연산자**

- 안전한 호출(safe call)
	- 일반 호출에 사용하는 점(.)을 물음표와 점(?.)으로 바꾼 것
	- 널이 될 수 있는 타입의 멤버에 접근 가능하게 해 줌
	- 수신 객체가 null이 아닐 때만 연산을 수행
		- val length1 = if (s != null) s.length else null
		- val length2 = s?.length
		- 위 둘은 같은 효과
- 엘비스 연산자(Elvis)
	- ?.의 결과로 null을 만들어내는 것 이상의 일이 필요한 경우 활용
	- 물음표와 콜론(?:)을 합친 연산자
	- 엘비스 프레슬리 이모티콘과 비슷하여 붙은 이름
	- else-if의 발음인 일시프와 비슷하다는 언어유희
	- '널 복합 연산자(null coalescing operator)'라고 함
	- 왼쪽 식의 값이 null이 아니면 왼쪽 식의 값이 전체 엘비스 식의 결과값, null이면 오른쪽 식의 값이 전체 결과값
	- 보통의 경우, 엘비스 연산자는 안전한 호출 다음에 사용함 -> 안전한 호출이 null 수신 객체에 대해 만들어 내는 null 대신 디폴트 값을 제공하기 위함
		- if (s != null) s.length else 0
		- s?.length ?: 0
		- 위 둘은 같은 효과



**39 널 아님 단언**

- null이 될 수 없다고 단언하기 위해 느낌표 두개(!!) 사용
- 'non-null assertion' 이라고 함
- 무언가를 경고하는 것처럼 보이기 위해 느낌표를 두개 사용
	- null과 관련된 모든 문제의 근원
		- 어떤 대상이 절대 null이 될 수 없다고 믿는 것
		- 어떤 대상이 null이 될 수 없음을 인식하지 못하는 것
- 'x!!'은 'x가 null일 수도 있다는 사실을 무시하라' or 'x가 null이 아님을 보증한다'라는 의미
	- x가 null이 아니면 x를 반환
	- x가 null이면 오류 발생시킴
- 보통 '!!'를 역참조와 함께 사용
	- s!!.length eq 3
- '널 아님 단언'보다는 안전한 호출이나 명시적 null 검사 활용을 권장
	- 널 아님 단언은 자바와 상호작용하는 경우, 코틀린이 널 가능성을 제대로 검사하지 못하는데 대상이 null이 아님을 알 수 있는 경우를 위해 도입된 것
- 같은 연산에 대해 널 아님 단언을 자주 사용하는 경우
	- 이 문제를 언급하는 적절한 단언과 함께 함수를 분리할 것
- 널 아님 단언은 꼭 필요할 때만 사용할 것


**40 확장 함수와 널이 될 수 있는 타입**

- 쇼트 서킷(short circuit)
	- 첫 번째 식이 true면 두 번째 식은 계산하지 않음
- 확장 함수는 this를 사용해 수신 객체를 표현
	- 수신 객체를 널이 될 수 있는 타입으로 지정하려면 확장 대상 타입 뒤에 ?를 붙이면 됨
- 널이 될 수 있는 타입을 확장할 때는 주의 필요
	- 일반적으로 널이 될 수 없는 확장을 정의하는 편이 나음
	- 널이 될 수 있는 타입의 확장 함수는 널 가능성을 감춰 가독성을 떨어트림


**41 제네릭스 소개**

- generic: 여러 가지 클래스에 적합한/여러 가지 클래스와 관계 있는
- 타입 제약을 느슨하게 해서 표현력을 최대로 제공
- 제네릭스는 파라미터화한 타입을 만듦
	- 파라미터화한 타입: 여러 타입에 대해 작동할 수 있는 컴포넌트
- 정의 방법
	- 클래스 이름 뒤에, 내부에 하나 이상의 제네릭 플레이스 홀더가 들어있는 부등호(<>)를 추가(ex. T, S...)
- 유니버설 타입(Any)
	- 모든 타입의 부모 타입
	- T 대신 써도 될 것 같지만 아님
		- 간단한 경우에는 작동
		- 구체적인 타입이 필요해지면 작동하지 않음
- 제네릭 함수 정의 방법
	- 부등호로 둘러싼 제네릭 타입 파라미터를 함수 이름 앞에 붙이면 됨 -> '제네릭 명세'
	- fun \<T\> 함수이름(arg: T): T {함수 본문}
- 제네릭 확장 함수
	- 수신 객체 앞에 제네릭 명세를 위치시켜야 함
	- 


**42 확장 프로퍼티**


- 확장 함수를 정의하는 것처럼 확장 프로퍼티를 정의 가능
	- 확장 대상 타입이 함수나 프로퍼티 이름 바로 앞에 위치
	- fun ReceiverType.extensionFunction() {...}
	- val ReceiverType.extensionProperty: PropType get() {...}
	- 확장 프로퍼티는 커스텀 게터가 필요
	- 확장 프로퍼티에 접근할 때마다 프로퍼티 값이 계산됨
- 파라미터가 없는 확장 함수는 항상 확장 프로퍼티로 변환 가능
	- 그래도 되는 것인지는 생각해봐야 함
	- 기능이 단순하고 가독성을 향상시키는 경우에만 프로퍼티를 권장
- 함수가 예외를 던질 경우 프로퍼티보다 함수를 사용할 것을 권장(코틀린 스타일 가이드)

- 스타 프로젝션(star projection): \*
	- 제네릭 인자 타입을 사용하지 않을 경우 대신 사용가능함
	- List\<\*\>를 사용하면 List에 담긴 원소의 타입 정보를 모두 잃어버리며 해당 원소는 Any?에만 대입 가능
		- List\<\*\>에 저장된 값이 널이 될 수 있는 타입인지에 대한 정보가 없기 때문



**43 break와 continue**


- goto 처럼 조건없이 점프하는 명령은 복잡하고 유지 보수하기 어려운 코드를 만들어 냄
- 코틀린은 break/continue를 사용해 '제한적인 점프'를 제공
- break/continue는 루프(for, while, do-while) 안에서만 사용 가능
	- continue: 루프의 시작 위치로만 점프
	- break: 루프의 끝으로만 점프
- 더 나은 메커니즘이 존재하여 실전 코틀린에서는 매우 드물게 사용

- 레이블
	- break/continue가 자신을 둘러싼 여러 루프의 경계 중 한군데로 점프 가능
	- 현재 실행 중인 맨 안쪽 루프의 영역에 제한되지 않고 점프 가능
	- '레이블@'과 같이 레이블 이름 다음에 @을 사용해 레이블을 붙임

- 더 간단하고 읽기 좋은 해법에는 보통 break/continue가 없음
	- 여러 가지 다른 접근 방법을 찾아보기!

